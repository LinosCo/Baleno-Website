// Prisma Schema per Baleno Booking System

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============ ENUMS ============

enum UserRole {
  ADMIN
  COMMUNITY_MANAGER
  USER
}

enum BookingStatus {
  PENDING        // In attesa di approvazione
  APPROVED       // Approvata
  REJECTED       // Rifiutata
  CANCELLED      // Cancellata dall'utente
  COMPLETED      // Completata
}

enum PaymentStatus {
  PENDING        // In attesa
  PROCESSING     // In elaborazione
  SUCCEEDED      // Completato con successo
  FAILED         // Fallito
  REFUNDED       // Rimborsato
  PARTIALLY_REFUNDED // Rimborsato parzialmente
}

enum PaymentMethod {
  CREDIT_CARD    // Carta di credito (Stripe)
  BANK_TRANSFER  // Bonifico bancario
  CASH           // Contanti
  OTHER          // Altro
}

enum ResourceType {
  ROOM           // Sala
  SPACE          // Spazio generico
  EQUIPMENT      // Attrezzatura
  SERVICE        // Servizio
}

enum ResourceCategory {
  MEETING_ROOM   // Sale riunioni
  COWORKING      // Spazi coworking
  EVENT_SPACE    // Spazi eventi
  EQUIPMENT      // Attrezzature
  SERVICE        // Servizi
  OTHER          // Altro
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  APPROVE
  REJECT
  CANCEL
  LOGIN
  LOGOUT
  ROLE_CHANGE
}

enum NotificationType {
  BOOKING_CONFIRMATION
  BOOKING_APPROVED
  BOOKING_REJECTED
  BOOKING_CANCELLED
  PAYMENT_SUCCESS
  PAYMENT_FAILED
  REFUND_PROCESSED
  REMINDER
}

enum RejectionReason {
  RESOURCE_UNAVAILABLE
  MAINTENANCE_SCHEDULED
  EVENT_ALREADY_BOOKED
  INSUFFICIENT_DOCUMENTATION
  CAPACITY_EXCEEDED
  PAYMENT_ISSUES
  OTHER
}

// ============ MODELS ============

model User {
  id            String   @id @default(cuid())
  email         String   @unique
  password      String?  // Null per OAuth users
  firstName     String
  lastName      String
  phone         String?
  role          UserRole @default(USER)

  // OAuth fields
  googleId      String?  @unique
  avatar        String?

  // Billing fields per fatturazione
  vatNumber     String?  // Partita IVA
  companyName   String?  // Nome Azienda
  fiscalCode    String?  // Codice Fiscale

  // Metadata
  emailVerified Boolean  @default(false)
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  lastLogin     DateTime?

  // Relations
  bookings      Booking[]
  payments      Payment[]
  refreshTokens RefreshToken[]
  passwordResetTokens PasswordResetToken[]
  notifications Notification[]

  // Audit fields per tracking chi ha fatto modifiche
  approvedBookings Booking[] @relation("BookingApprover")
  rejectedBookings Booking[] @relation("BookingRejector")

  @@index([email])
  @@index([role])
  @@map("users")
}

model RefreshToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([token])
  @@map("refresh_tokens")
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([token])
  @@map("password_reset_tokens")
}

model Resource {
  id          String            @id @default(cuid())
  name        String
  description String?           @db.Text
  type        ResourceType
  category    ResourceCategory  @default(OTHER)

  // Capacity and pricing
  capacity    Int?              // Capacit√† persone
  pricePerHour Decimal          @db.Decimal(10, 2)
  minBookingHours Int?          @default(1) // Ore minime prenotazione

  // Availability
  isActive    Boolean           @default(true)

  // Maintenance mode
  maintenanceMode Boolean       @default(false)
  maintenanceStart DateTime?
  maintenanceEnd   DateTime?
  maintenanceReason String?     @db.Text

  // Additional info
  images      String[]          // URLs delle immagini
  amenities   String[]          // Servizi inclusi (wifi, proiettore, etc)
  features    String[]          // Caratteristiche (lavagna, AC, etc)
  tags        String[]          // Tag per ricerca e filtri
  rules       String?           @db.Text
  restrictions String?          @db.Text // Restrizioni d'uso

  // Location (opzionale)
  location    String?
  floor       String?

  // Accessibility
  wheelchairAccessible Boolean  @default(false)

  // Metadata
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  // Relations
  bookings    Booking[]
  additionalBookings BookingResource[] @relation("BookingAdditionalResources")

  @@index([type])
  @@index([category])
  @@index([isActive])
  @@index([maintenanceMode])
  @@map("resources")
}

model Booking {
  id          String        @id @default(cuid())

  // Relations
  userId      String?       // Nullable per prenotazioni manuali admin
  user        User?         @relation(fields: [userId], references: [id], onDelete: Cascade)

  resourceId  String
  resource    Resource      @relation(fields: [resourceId], references: [id], onDelete: Restrict)

  // Manual booking fields (prenotazioni create da admin senza account utente)
  isManualBooking   Boolean   @default(false)
  manualGuestName   String?   // Nome ospite per prenotazione manuale
  manualGuestEmail  String?   // Email ospite per prenotazione manuale
  manualGuestPhone  String?   // Telefono ospite per prenotazione manuale
  createdByAdminId  String?   // ID dell'admin che ha creato la prenotazione manuale

  // Booking details
  startTime   DateTime
  endTime     DateTime

  // Status tracking
  status         BookingStatus  @default(PENDING)
  paymentStatus  PaymentStatus  @default(PENDING)
  reminderSent   Boolean        @default(false)

  // Payment and invoice tracking (admin actions)
  paymentReceived Boolean       @default(false)
  paymentReceivedAt DateTime?
  paymentReceivedBy String?

  invoiceIssued   Boolean       @default(false)
  invoiceIssuedAt DateTime?
  invoiceIssuedBy String?

  // Approval/Rejection info
  approvedBy  String?
  approver    User?         @relation("BookingApprover", fields: [approvedBy], references: [id])
  approvedAt  DateTime?

  rejectedBy  String?
  rejector    User?         @relation("BookingRejector", fields: [rejectedBy], references: [id])
  rejectedAt  DateTime?
  rejectionReason String?   @db.Text

  cancelledAt DateTime?
  cancellationReason String? @db.Text

  // Additional info
  title       String        // Titolo/motivo prenotazione
  description String?       @db.Text
  attendees   Int?          // Numero partecipanti
  notes       String?       @db.Text
  isPrivate   Boolean       @default(false) // Se true, nasconde i dettagli nel calendario pubblico

  // Metadata
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  // Relations
  payments    Payment[]
  additionalResources BookingResource[]

  @@index([userId])
  @@index([resourceId])
  @@index([status])
  @@index([paymentStatus])
  @@index([startTime, endTime])
  @@map("bookings")
}

model BookingResource {
  id          String   @id @default(cuid())

  // Relations
  bookingId   String
  booking     Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  resourceId  String
  resource    Resource @relation("BookingAdditionalResources", fields: [resourceId], references: [id], onDelete: Restrict)

  // Quantity
  quantity    Int      @default(1)

  // Metadata
  createdAt   DateTime @default(now())

  @@unique([bookingId, resourceId])
  @@index([bookingId])
  @@index([resourceId])
  @@map("booking_resources")
}

model Payment {
  id          String        @id @default(cuid())

  // Relations
  bookingId   String
  booking     Booking       @relation(fields: [bookingId], references: [id], onDelete: Restrict)

  userId      String
  user        User          @relation(fields: [userId], references: [id], onDelete: Restrict)

  // Payment details
  amount        Decimal       @db.Decimal(10, 2)
  currency      String        @default("EUR")
  status        PaymentStatus @default(PENDING)
  paymentMethod PaymentMethod @default(CREDIT_CARD)

  // Stripe integration
  stripePaymentIntentId   String? @unique
  stripeCheckoutSessionId String? @unique
  stripeChargeId          String? @unique
  stripeRefundId          String?

  // Bank transfer integration
  bankTransferCode     String?   @unique
  bankTransferVerified Boolean   @default(false)
  bankTransferDate     DateTime?

  // Payment expiry
  expiresAt DateTime?

  // Receipt
  receiptUrl  String?

  // Refund info
  refundedAmount Decimal?   @db.Decimal(10, 2)
  refundedAt     DateTime?
  refundReason   String?    @db.Text

  // Metadata
  metadata    Json?         // Per eventuali dati aggiuntivi Stripe
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  @@index([bookingId])
  @@index([userId])
  @@index([status])
  @@index([stripePaymentIntentId])
  @@index([stripeCheckoutSessionId])
  @@index([bankTransferCode])
  @@map("payments")
}

model Notification {
  id          String           @id @default(cuid())

  // Relations
  userId      String
  user        User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Notification details
  type        NotificationType
  title       String
  message     String           @db.Text

  // Status
  read        Boolean          @default(false)
  readAt      DateTime?

  // Email tracking
  emailSent   Boolean          @default(false)
  emailSentAt DateTime?

  // Metadata
  metadata    Json?            // Per dati aggiuntivi (link, azioni, etc)
  createdAt   DateTime         @default(now())

  @@index([userId])
  @@index([read])
  @@index([createdAt])
  @@map("notifications")
}

// ============ AUDIT & SECURITY ============

model AuditLog {
  id          String      @id @default(cuid())

  // Actor
  userId      String?
  userEmail   String?
  userRole    String?

  // Action details
  action      AuditAction
  entity      String      // "booking", "resource", "user", etc
  entityId    String?     // ID della risorsa modificata

  // Details
  description String      @db.Text
  metadata    Json?       // Dati aggiuntivi (before/after, IP, etc)

  // Request info
  ipAddress   String?
  userAgent   String?

  // Timestamp
  createdAt   DateTime    @default(now())

  @@index([userId])
  @@index([action])
  @@index([entity])
  @@index([createdAt])
  @@map("audit_logs")
}

model PaymentSettings {
  id                    String   @id @default(cuid())

  // Stripe configuration
  stripeEnabled         Boolean  @default(true)
  stripePublishableKey  String?
  stripeSecretKey       String?  @db.Text // Encrypted
  stripeWebhookSecret   String?  @db.Text // Encrypted

  // Bank transfer configuration
  bankTransferEnabled   Boolean  @default(false)
  bankName              String?
  bankAccountHolder     String?
  bankIBAN              String?
  bankBIC               String?
  bankAddress           String?
  bankTransferNote      String?  @db.Text

  // Payment settings
  paymentDeadlineDays   Int      @default(2)
  currency              String   @default("EUR")
  taxRate               Float    @default(22) // IVA 22%

  // Invoice settings
  invoicePrefix         String   @default("INV")
  invoiceStartNumber    Int      @default(1)
  currentInvoiceNumber  Int      @default(1)

  // Reminder settings
  paymentReminderHours  Int      @default(24)
  sendReminders         Boolean  @default(true)

  // Metadata
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@map("payment_settings")
}

// ============ VIEWS & ANALYTICS (opzionale, per future implementazioni) ============

// Potremmo aggiungere tabelle per:
// - Review/Feedback sulle prenotazioni
// - Event management (eventi pubblici)
// - Membership/Subscriptions
// - File uploads (documenti, immagini)
